// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: customer_query.sql

package query

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO customers (id, first_name, last_name, email, phone, date_of_birth, address_street, address_city, address_state, address_zip_code, address_country, status, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
RETURNING id, first_name, last_name, email, phone, date_of_birth, address_street, address_city, address_state, address_zip_code, address_country, status, deleted_at, created_at, updated_at
`

type CreateCustomerParams struct {
	ID             pgtype.UUID
	FirstName      string
	LastName       string
	Email          string
	Phone          pgtype.Text
	DateOfBirth    string
	AddressStreet  pgtype.Text
	AddressCity    pgtype.Text
	AddressState   pgtype.Text
	AddressZipCode pgtype.Text
	AddressCountry pgtype.Text
	Status         string
	CreatedAt      pgtype.Timestamp
	UpdatedAt      pgtype.Timestamp
}

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (Customer, error) {
	row := q.db.QueryRow(ctx, createCustomer,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.Phone,
		arg.DateOfBirth,
		arg.AddressStreet,
		arg.AddressCity,
		arg.AddressState,
		arg.AddressZipCode,
		arg.AddressCountry,
		arg.Status,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.DateOfBirth,
		&i.AddressStreet,
		&i.AddressCity,
		&i.AddressState,
		&i.AddressZipCode,
		&i.AddressCountry,
		&i.Status,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findCustomerByEmail = `-- name: FindCustomerByEmail :one
SELECT id, first_name, last_name, email, phone, date_of_birth, address_street, address_city, address_state, address_zip_code, address_country, status, deleted_at, created_at, updated_at FROM customers
WHERE email = $1 LIMIT 1
`

func (q *Queries) FindCustomerByEmail(ctx context.Context, email string) (Customer, error) {
	row := q.db.QueryRow(ctx, findCustomerByEmail, email)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.DateOfBirth,
		&i.AddressStreet,
		&i.AddressCity,
		&i.AddressState,
		&i.AddressZipCode,
		&i.AddressCountry,
		&i.Status,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findCustomerByID = `-- name: FindCustomerByID :one
SELECT id, first_name, last_name, email, phone, date_of_birth, address_street, address_city, address_state, address_zip_code, address_country, status, deleted_at, created_at, updated_at FROM customers
WHERE id = $1 LIMIT 1
`

func (q *Queries) FindCustomerByID(ctx context.Context, id pgtype.UUID) (Customer, error) {
	row := q.db.QueryRow(ctx, findCustomerByID, id)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.DateOfBirth,
		&i.AddressStreet,
		&i.AddressCity,
		&i.AddressState,
		&i.AddressZipCode,
		&i.AddressCountry,
		&i.Status,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCustomer = `-- name: UpdateCustomer :exec
UPDATE customers
SET first_name = $2, last_name = $4, email = $3, phone = $5, date_of_birth = $6, address_street = $7, address_city = $8, address_state = $9, address_zip_code = $10, address_country = $11, status = $12
WHERE id = $1
`

type UpdateCustomerParams struct {
	ID             pgtype.UUID
	FirstName      string
	Email          string
	LastName       string
	Phone          pgtype.Text
	DateOfBirth    string
	AddressStreet  pgtype.Text
	AddressCity    pgtype.Text
	AddressState   pgtype.Text
	AddressZipCode pgtype.Text
	AddressCountry pgtype.Text
	Status         string
}

func (q *Queries) UpdateCustomer(ctx context.Context, arg UpdateCustomerParams) error {
	_, err := q.db.Exec(ctx, updateCustomer,
		arg.ID,
		arg.FirstName,
		arg.Email,
		arg.LastName,
		arg.Phone,
		arg.DateOfBirth,
		arg.AddressStreet,
		arg.AddressCity,
		arg.AddressState,
		arg.AddressZipCode,
		arg.AddressCountry,
		arg.Status,
	)
	return err
}
